/*global console self caches fetch setTimeout clearTimeout*/
/*
   Network first cache strategy
 */
const CACHE_NAME = "v1";
const FALLBACK_TO_CACHE_TIMEOUT = 30000;
const PREFETCH_CACHE_FILES = [
    "/",
    "/login",
    "/about",
    "/static/node_modules/@fortawesome/fontawesome-free/css/all.min.css",
    "/static/assets/css-dist/main.css",
    "/static/assets/css/icons.css",
    "/static/assets/ts-dist/global.bundle.js",
    "/static/assets/ts-dist/admin.bundle.js",
    "/static/node_modules/@alpinejs/persist/dist/cdn.min.js",
    "/static/node_modules/alpinejs/dist/cdn.js",
    "/offline",
];
const CACHE_REQUEST_METHOD_ALLOWLIST = ["GET"];
const CACHE_REQUEST_HOST_ALLOWLIST = [self.location.host];

var db, openOrCreateDB;


function initIndexDB() {
    openOrCreateDB = indexedDB.open("offline-videos", 1);
    openOrCreateDB.addEventListener("error", () => {
        console.error("[ServiceWorker] Error opening IndexedDB database");
        dbOpen = false;
    });
    openOrCreateDB.addEventListener("success", () => {
        console.log("[ServiceWorker] Successfully opened IndexedDB database");
        db = openOrCreateDB.result;
    });
    openOrCreateDB.addEventListener("upgradeneeded", init => {
        db = init.target.result;

        db.onerror = () => {
            console.error("[ServiceWorker] Error loading IndexedDB database");

        }

        db.createObjectStore("videos");
    });
}

const shouldCacheReq = (req) => {
    // eslint-disable-next-line no-undef
    const urlHost = new URL(req.url).host;
    return CACHE_REQUEST_METHOD_ALLOWLIST.includes(req.method) && CACHE_REQUEST_HOST_ALLOWLIST.includes(urlHost);
};

function getDownloads() {
    return new Promise(function(resolve) {
        console.log("[ServiceWorker] Fetching downloads from IndexedDB")
        let transaction = db.transaction(["videos"], "readonly");
        let store = transaction.objectStore("videos");
        let request = store.getAll();
        request.onsuccess = () => {
            console.log("[ServiceWorker] Results: " + request.result)
            return resolve(request.result);
        }
        request.onerror = () => {
            console.error("[ServiceWorker] Error fetching downloads from IndexedDB");
            return resolve();
        }
        console.log("[ServiceWorker] No downloads found in IndexedDB")
    })
}

self.addEventListener("install", function (e) {
    //console.log("[ServiceWorker] Installed");
    e.waitUntil(
        caches.open(CACHE_NAME).then(function (cache) {
            //console.log("[ServiceWorker] Caching cacheFiles");
            return cache.addAll(PREFETCH_CACHE_FILES);
        }),
    );
});

self.addEventListener("activate", function (e) {
    //console.log("[ServiceWorker] Activated");
    e.waitUntil(
        caches.keys().then((cacheNames) => {
            return Promise.all(
                cacheNames.map((cacheName) => {
                    if (cacheName !== CACHE_NAME) {
                        return caches.delete(cacheName);
                    }
                }),
            );
        }),
    );
});

self.addEventListener("fetch", async (e) =>  {
    //{{if ne .edgeURL ""}}
    if (e.request.method === "GET") {
        let matches = e.request.url.match("http[s]?:\\/\\/([^\\/]+)\\/vod\\/([^\\/]+).*"); // Regex Group 1: Host, Group 2: VOD ID
        if (matches != null && matches.length >= 2) {
            if (matches[1] === "{{.edgeURL}}") {
                console.log("[ServiceWorker] Fetching", matches[2])
                // TODO: Check, if VOD is in cache, else load from network
            }
        }

        matches = e.request.url.match("http[s]?:\\/\\/([^\\/]+)\\/(.+)"); // Regex Group 1: Host, Group 2: api call
        if (matches != null && matches.length >= 2) {
            if (matches[2].startsWith("storeOffline")) {
                console.log("[ServiceWorker] Storing offline", matches[2])
            } else if (matches[2].startsWith("removeOffline")) {
                console.log("[ServiceWorker] Removing offline", matches[2])
            } else if (matches[2].startsWith("getDownloads")) {
                console.log("[ServiceWorker] Fetching downloads")
                let downloads = await getDownloads(e)
                e.respondWith(new Response(JSON.stringify(downloads), { headers: { "Content-Type": "application/json" }}));
            } else {

            }
        }
    }
    //{{end}}

    if (!shouldCacheReq(e.request)) {
        //console.debug("Cache exception");
        return;
    }

    const fromNetwork = (request, timeout) =>
        new Promise((fulfill, reject) => {
            const timeoutId = setTimeout(reject, timeout);
            fetch(request).then((response) => {
                clearTimeout(timeoutId);
                fulfill(response.clone());
                caches.open(CACHE_NAME).then((cache) => cache.put(request, response));
            }, reject);
        });

    const fromCache = (request) =>
        caches.open(CACHE_NAME).then((cache) => cache.match(request).then((matching) => matching));

    e.respondWith(fromNetwork(e.request, FALLBACK_TO_CACHE_TIMEOUT).catch(() => fromCache(e.request)));
});
